//======================================
// UNDO text changes
//======================================

All is well on Win, Mac, iOS.
Android's "Hacker's Keyboard" (a keyboard 
alternative from the Play Store that 
selectably replaces the built-in keyboard) 
supports undo via Ctrl-Z, as well as 
Ctrl-X/C/V. There is no other known way 
to undo text changes on Android.

//======================================
// Builtin functions and operators
//======================================

// All numbers are double precision, 
// illegal operations may produce NAN

// The default sample for species that
// are not explicitly put in a sample:

vessel

// Literals:

true false (integer) (float) (string) 

// Prefix number and bool operators:

-  not

// Infix number and bool operators, 
// standard math precedence:

+  -  *  /  ^  and  or  =  <>  <=  >=  <  > 

// Infix species operators (eq, not eq):

=  <>

// Infix string operators (concat, eq, not eq):

+  =  <>

// Infix list operators (concat, eq, not eq):

++  =  <>

// All of the following are normally-bound 
// variables in the initial environment
// they can be redefined, resulting in 
// hiding the built-in functions

pos(n)    // if n=NaN or n<0 then 0 else n end
int(n)    // the integer nearest n

// From the C# Math and Double classes:

pi              // 3.14159265358979323846
e               // 2.7182818284590452354
maxNumber
minNumber
positiveInfinity
negativeInfinity
NaN             // (NaN = NaN) = true

abs(n)
arccos(n)
arcsin(n)
arctan(n)
arctan2(n,m)
ceiling(n)
cos(n)
cosh(n)
exp(n)
floor(n)
log(n)          // base e
max(n)
min(n)
sign(n)
sin(n)
sinh(n)
sqrt(n)
tan(n)
tanh(n)

//======================================
// List manipulation
//======================================

list v = ..         list definition
function f(list v, ..){..} list parameter
[e1,..,en]          fixed length list
l1 ++ l2            list concatenation
l()                 length
l(n)                indexing, from 0
l(n,m)              sublist (start,length)
[t1 v1, .., tn vn] = e
   fixed length pattern matching
   ti can be 'number', 'list', etc.
[..ti vi..] ++ list v = e
list v ++ [..ti vi..] = e
   variable length pattern matching

//Examples: constructors/destructors
list l = [0] ++ [1,2]      // =[0,1,2]
number first = l(0)        // =0
list late = l(1, l()-1)    // =[1,2]
list early = l(0, l()-1)   // =[0,1]
number last = l(l()-1)     // =2
//Examples: pattern matching
[number n0 n1 n2] = l
[number first] ++ list late = l
list early ++ [number last] = l
function f([number n]++list l) {l++[n]}
list r = f([0,1,2])   // = [1,2,0]

//Draw-from expressions:
draw n from f   
// = [f(0), ..., f(n-1)]
draw n from [.. f_i ..] 
// = [.. draw n from f_i ..]

//Draw-from statements:
//the resulting lists are plotted 
//instead of returned

//======================================
// Random Variables
//======================================

rand(omega w) { ... w(0) ... w(1) ... }
// is an expression denoting a random variable
// that accesses the sample space w of type omega.
// Each w(i) is an orthogonal [0..1] dimension 
// of the sample space yielding a random
// number. Separate random variables access 
// separate subdimensions but w(i) is always 
// the same number for the same random variable
// and the same w. (See the Omega language.)

rand(omega w) { w(0) } 
// is a pure [0..1] random number generator

random X = ...
// declares a variable X of type random variable
// and expects a random variable to bind to it.
// Also, "random" can be used as a parameter type:
function f(random X) { ... }

random X(omega w) {...}
// is a declaration of a random variable named X, 
// on sample space w, equivalent to:
random X = rand(omega w) {...}

<-X 
// samples a random variable X (it creates a fresh
// sample space and passes it to the random variable)

X(w) 
// samples X from a particular sample space w, e.g.:
function gtzero(random X) {
   rand(omega w) { X(w)>0 }
}
// returns a discrete boolean random variable 
// based on X>0

X | Y
// a random variable which is X conditioned 
// on Y = true, e.g.:    
X | gtzero(X)
// if sampled this returns only the elements of X that
// satisfy gtzero(X), i.e. the positive ones.
// This works by rejection sampling, hence not very
// efficienty in general, and sampling will loop if the 
// condition never holds.

draw n from X
draw n from [X1,...,Xn]
// draw a number of samples from a random variable or
// a list of random variables and show a density plot.
// When used as expressions, they return the lists
// of numbers instead of plotting them

parameter n <- X
// declares a number n and assigns to it a random
// number drawn from random variable X. 
// Hence it is equivalent to:
number n = <-X
// but in addition, these declared numerical 
// parameters can be manipulated in the GUI

//======================================
// Distributions
//======================================

// Via the above random variables, distributions 
// are programmable, e.g.:
function uniform(number a b) {
   rand(omega w) { w(0)*(b-a)+a }
}
// uniform(3,5) returns a random variable with a
// uniform distribution between 3 and 5.

// Although all distributions are programmable,
// the following distributions are built-in:

uniform(lo,hi), 
normal(mean,stdev)        // Gauss
parabolic(mean,halfwidth) // Epanechnikov
exponential(lambda)
bernoulli(p)  // true with prob. p, or false

//======================================
// Observation (see Flow-expressions)
//======================================

observe(f)   // same as observe(f,vessel)
observe(f,s) // observe a flow f in sample s
             // returning a number; e.g.:
observe(kelvin,s) // temperature of s
observe(volume,s) // volume of s (L)
observe(a,s) // molarity of a in s (mol/L)
observe(∂a,s)     // derivative of a
observe(a+2b^2,s) // combined observations
observe(var(a),s) // requires LNA active
observe(time,s) // nonzero only if s was the
 // *input* sample of equilibrate s'=s for t

//======================================
// Flow-expressions
//======================================

// Current time:

time

// Current temperature:

kelvin
celsius

// Derivatives, valid in 'report' 
// but not in {{...}} rates:

∂ a      // first time derivative
diff(a)  // same as ∂a
sdiff(a) // symbolic differentiation

// Noise with mean = mean(a)
// and variance = mean(a):

poisson(a)    

// Noise with mean = mean(a) 
// and variance = mean(b):

gauss(a,b)  

// Variance of a linear combination
// of species:

var(a)

// Covariance of two linear combianations
// of species:

cov(a,b)

// conditional flow
// e.g. cond(a<b,a,b) = min(a,b):

cond(a,b,c)

/* Flow-expressions denote time courses
and are found in 'observe( ... , S)'
for samples, in 'report ...' statements 
for plotting, and in {{ ... }} special
rate brackets to express arbitrary
kinetic  functions. Flow-expressions are
a subset of expressions that include
boolean and numerical operators and
where species 's' are intepreted as
molarity(s)(t): the  numeric
concentration value of 's' at time 't'.

More technically, flow-expressions are
first *evaluated* to produce *flows* 
(while ordinary expressions are
evaluated to produce *values*). Flows
are data structures consisting
exclusively of numeric and boolean
operators over  booleans, numbers,
species, and some special entities such
as 'time'. The  process of producing
flows can involve ordinary function
invocation and if-then-else conditional
execution, but those do not appear in
resulting flows. At a  later stage,
flows are *oberved*, that is evaluated
at multiple time points,  during
plotting or in the evaluation of
reaction rates during simulations. Flows 
are exactly the labels that appear in
chart legends.

When using a defined function inside a
flow-expession (i.e. in a 'report ...'
or  '{{ ... }}' context), the body of
the function is interpreted as a flow-
expression in that context.
*/

// Ex.: Arrhenius equation
// (temperature-dependante rates)

function Arrhenius(flow cf ae) { 
   cf*exp(-ae/(8.3144598*kelvin)) 
}

// Use the Arrhenius function for 
// the rate of a reaction

species a,b @ 1M
a + b -> Ø  {{ Arrhenius(2,50)*a*b }}

// plot a, b, and the instantanous 
// rate of their reaction over time

report a, b, Arrhenius(2,50)*a*b     
equilibrate for 10                        

// If vs. cond

species a @ 1M
species b @ 0M
a -> Ø
Ø -> b

// min is built-in; it plots 
// min(molarity(a)(t), molarity(b)(t)) 
// at any time t:

report min(a,b) 

// here is the equivalent conditional flow:

report cond(a<b,a,b)

// invalid flow: unlike 'cond', 'if' is not 
// a flow operator, so it cannot compare flows:

report if a<b then a else b end // ERROR   

// but 'if' can choose between two flows 
// a or b based on a (timeless) condition:

report if 3>2 then a else b end    

//======================================
// Optimization
//======================================

argmin(f, i, d) // BFGS Optimizer
//f: list -> [number, list]
//   input is a list of numbers (the parameters to optimize)
//   outputs are the number cost of those parameters 
//   and a list of partial gradients for the parameters 
//i: list of numbers
//   initial guess for the parameters
//d: number
//   numeric tolerance for convergence, e.g. 1e-2


