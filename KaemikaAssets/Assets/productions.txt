============================================================
GOLD Parser Builder
Version 5.2.0.
============================================================


========================================
Grammar
========================================

"Name"    = Kaemika grammar
"Author"  = Luca Cardelli
"Version" = 1
"About"   = A Language for Modularizing Chemistry
          
"Case Sensitive" = True
"Start Symbol"   = <Top>

Id        = ({Letter}|{Greek and Coptic})({AlphaNumeric}|{Greek and Coptic}|'_'|{Superscripts and Subscripts}|'')*           ! Letter followed by alphanumerics or single-quote, underscore, Unicode sup/sub
Integer   = {Digit}+
Float     = {Digit}+ '.' {Digit}+
Double    = {Digit}+ ('.' {Digit}+)? [Ee] [+-]? {Digit}+
{StringChar} = {All Printable} - ["\]
QuotedString = '"' ({StringChar} | '\'{All Printable})* '"'
          
Comment Line  = '//'
Comment Start = '/*'
Comment End   = '*/'
Comment Block @= { Nesting = All }
                
! PREAMBLE --------------------------------------------

<Top>           ::=  <Statements>
             
! ABSTRACTIONS  --------------------------------------------
                          
<Function>       ::= Id '=' <Expression>                                     ! binding a function value to a function id
                    | Id <Fun>                                               ! function id definition
<Fun>            ::= <Headers> '{' <Expression> '}'                          ! function abstraction

<Network>        ::= Id '=' <Expression>                                     ! binding a network value to a network id
                    | Id <Net>                                               ! network id definition
<Net>            ::= <Header> '{' <Statements> '}'                           ! network abstraction (networks are nothing but functions that do not return values)

<Random>         ::= Id '=' <Expression>                                     ! binding a random variable value to a random variabl id
                    | Id <Rand>                                              ! random variable id definition
<Rand>           ::= '(' 'omega' Id ')' '{' <Expression> '}'                 ! random variable abstraction
                  
<EmptySample>    ::= Id '{' <Expression> <Volume> ',' <Expression> <Temperature> '}'
<Sample>         ::= Id '=' <Expression>                                     ! binding a sample value to a sample id
                    | <EmptySample>                                          ! empty sample definition, parameterized by volume and temperature
                    | Id                                                     ! empty sample definition, default volume (1 mL) and temperature (20 Celsius)

<Species>        ::= Id '=' <Expression>                                     ! binding a species value to a species id
                    | '{' <Substances> '}'                                   ! declaration of multiple species (unallocated)
                    | <Substances> '@' <Expression> <Quantity> <Allocation>  ! allocation of multiple <Ids> species to a sample, 
                                                                             !     short for '{'<Substances>'}' ';' 'amount' <Ids> '@' <Expression> <Quantity> <Allocation>

<Headers>        ::= <Headers> <Header>
                    | <Header>
                                      
<Header>         ::= '(' <Params> ')'

<Params>           ::= <ParamSeq>
                    |                                                  
<ParamSeq>         ::= <ParamSeq> ',' <Param>
                    | <Param>

<Param>          ::= 'bool' <Ids>                  ! booleans      
                    | 'number' <Ids>               ! numbers
                    | 'string' <Ids>               ! strings
                    | 'list' <Ids>                 ! lists
                    | 'flow' <Ids>                 ! for functions parameterized by flows in flow-expressions                   
                    | 'species' <Ids>              ! species are values. n.b. individual reactions are not values, but networks are
                    | 'sample' <Ids>               ! samples are containers that have volume and temperature, populated with species that have concentrations
                    | 'function' <Ids>             ! functions can receive and return values, species, functions, and networks  
                    | 'network' <Ids>              ! networks can receive values, species, functions, and networks, and return nothing    
                    | 'random' <Ids>               ! random variables    
                    | <Pattern>                    ! list pattern matching 

<Pattern>       ::= '[' <Params> ']'                  ! a fixed length list pattern
                    | '[' <Params> ']' '++' 'list' Id  ! a variable length list pattern, with tail on the right
                    | 'list' Id '++' '[' <Params> ']'  ! a variable length list pattern, with tail on the left

<Ids>           ::= <Ids> Id
                    | Id
                    
<IdSeq>         ::= <IdSeq> ',' Id
                    | Id
                                                              
<Allocation>     ::= 'in' <Expression>     ! allocation of species in a sample
                    |                      ! short for 'in' 'vessel'
<Substances>     ::= <Substances> ',' <Substance>
                    | <Substance>
<Substance>      ::= Id '#' <Expression>
                    | Id
                  
! STATEMENTS --------------------------------------------

<Statements>    ::= <Statements> <Statement>  
                    |

<Statement>     ::=   <Net Instance>                          ! there are no obligatory delimiter characters between statements. LALR FTW!
                    | <Reaction>                              ! reactions are the only statements not prefixed by a keyword (other than instances)
                    | 'bool' Id '=' <Expression>              ! binding a bool value to a bool id
                    | 'number' Id '=' <Expression>            ! binding a number value to a number id
                    | 'string' Id '=' <Expression>            ! binding a string value to a string id
                    | 'list' Id '=' <Expression>              ! binding a list value to a list id
                    | 'flow' Id '=' <Expression>              ! binding a flow value to a flow id
                    | 'random' <Random>                       ! binding a random variable value to a random variable id
                    | 'constant' <IdSeq>                      ! an undetermined constant (used for exporting ODEs containing symbolic constants)
                    | 'parameter' Id '<-' <Expression>        ! drawing a parameter from a random variable (and displaying it in the GUI)
                    | 'species' <Species>                     ! binding a species to a species id or species def
                    | 'sample' <Sample>                       ! binding a sample to a sample id or sample def
                    | 'function' <Function>                   ! binding a function to a function id or function def
                    | 'network' <Network>                     ! binding a network to a network id or network def
                    | <Pattern> '=' <Expression>              ! binding list elements to ids; length and types must match                  
                    | 'amount' <Ids> '@' <Expression> <Quantity> <Allocation>  ! set initial quantity of species in a sample
                    | 'report' <Reports>                                       ! report species for plotting (can use arithmetic, but restrictions apply)
                    | 'if' <Expression> 'then' <Statements> <Else>             ! conditional
                    | <Draw>                                                   ! draw samples from (lists of) functions or random variables and plot them
                    | ';'                                                      ! rarely used optional syntactic noise for same-line multiple statements
                    
                    | 'mix' Id '=' <ExpressionSeq>                                ! mix samples and name the new sample
                    | 'split' <IdSeq> '=' <Expression> 'by' <ExpressionSeq>       ! split a sample by propotions and name them
                    | 'split' <IdSeq> '=' <Expression>                            ! split in equal parts
                    | 'dispose' <ExpressionSeq>                                   ! dispose samples (those samples cannot be reused)
                    | 'regulate' <IdSeq> '=' <ExpressionSeq> 'to' <Expression> <Temperature>  ! change samples temperature to value (heat or cool)
                    | 'regulate' <IdSeq> 'to' <Expression> <Temperature>                      ! short for 'regulate' Ids '=' Ids 'to' ...
                    | 'concentrate' <IdSeq> '=' <ExpressionSeq> 'to' <Expression> <Volume>    ! change samples volume to value (evaporate or dilute)
                    | 'concentrate' <IdSeq> 'to' <Expression> <Volume>                        ! short for 'concentrate' Ids '=' Ids 'to' ...
                    | 'equilibrate' <IdSeq> '=' <ExpressionSeq> <EndCondition>    ! integrate samples for a time, and name the new samples
                    | 'equilibrate' <IdSeq> <EndCondition>                        ! short for 'equilibrate' Ids '=' Ids <EndCondition> (reusing the sample Ids)
                    | 'equilibrate' <EndCondition>                                ! short for 'equilibrate' 'vessel' '=' 'vessel' <EndCondition> (default sample)
                
<Net Instance>   ::= Id '(' <Expressions> ')'

<Else>           ::=  'elseif' <Expression> 'then' <Statements> <Else>  ! cascading if statements: else is optional
                    | 'else' <Statements> 'end'
                    | 'end'

<Draw>          ::= 'draw' <Expression> 'from' <Expression>
                                   
! REACTIONS --------------------------------------------

<Reaction>      ::= <Transition> 
                    | <Complex> '>>' <Transition>                 ! optional catalysis notation, A >> B -> C == A + B -> A + C, etc.
               
<Transition>    ::= <Complex> '->' <Complex>                                              ! default rate (collision frequncy = 1.0, activation energy = 0.0)
                    | <Complex> '->' '{' <Rate> '}' <Complex>                             ! rate in the middle of reaction
                    | <Complex> '->' <Complex> '{' <Rate> '}'                             ! or rate after reaction
                    | <Complex> '<->' <Complex>                                           ! reversible, default rate (= 1.0, 0.0)
                    | <Complex> '{' <Rate> '}' '<->' '{' <Rate> '}' <Complex>             ! rate in the middle of reaction
                    | <Complex> '<->' <Complex> '{' <Rate> '}' '{' <Rate> '}'             ! or rate after reaction, {reverse} then {direct}

<Rate>          ::= <Expression>                                                          ! collision frequency (with activation energy = 0.0)
                    | <Expression> ',' <Expression>                                       ! collision frequency, activation energy (joules per mole)
                    | '{' <Expression> '}'                                                ! arbitrary kinetic law: any function from a sample to a non-negative number

<Complex>       ::= <Complex> '+' <Simplex>
                    | <Simplex>
                
<Simplex>       ::= Integer Id                                          ! stoichiometry: '2a' is the same as 'a + a'
                    | Id '*' Id                                         ! stoichiometry: 'n * a' is the same as 'a + ... + a' n times for integer n>=0
                    | Id                                                ! a species
                    | '#'                                               ! zero species: for creation and degradation
                    | 'Ø'                                               ! zero species: for creation and degradation

! EXPRESSIONS --------------------------------------------
          
<Expression>    ::=  <Op Exp>                                               ! see below
                 
<Base Exp>      ::= <Fun Instance> 
                    | 'true' | 'false'                                      ! bool literal
                    | Integer | Float | Double                              ! double floating point literal. use int(n) to round to integers
                    | QuotedString                                          ! double-quoted string literal. use \" and \\ to represent " and \
                    | 'if' <Expression> 'then' <Expression> <Else Exp>      ! no statements allowed inside if-expressions: uses if-statements for that
                    | 'fun' <Fun>                                           ! function abstraction
                    | 'net' <Net>                                           ! network abstraction
                    | 'rand' <Rand>                                         ! random variable bstraction
                    | '(' <Expression> ')'                                  ! parenthesized expression
                    | '[' <Expressions> ']'                                 ! list
                    | <Draw>                                                ! draw a list from (lists of) functions or random variables
                    | 'define' <Statements> 'yield' <Expression>            ! numerous but mild shift-reduce conflicts because no 'end' bracket. 
                                                                            ! E.g. (define number n = 3 yield n) + 3   vs. define number n = 3 return (n + 3)
                                                                            ! resolved as the latter
                  
<Fun Instance>      ::= Id                                                  ! built-in math library operators, and pi and e, follow this syntax too
                    | <Fun Instance> '(' <Expressions> ')'                  ! function invocations can use currying             
                     
<Else Exp>       ::=  'elseif' <Expression> 'then' <Expression> <Else Exp>  ! cascading if expressions: else is compulsory
                    | 'else' <Expression> 'end'
                           
<Expressions>    ::= <ExpressionSeq>
                    |
<ExpressionSeq>  ::= <ExpressionSeq> ',' <Expression>
                    | <Expression>
                                        
<Reports>        ::= <Reports> ',' <Report>
                    | <Report>
                    
<Report>         ::= <Expression> 'as' <Expression>
                    | <Expression> 

<EndCondition>   ::= 'for' <Expression>
                  
! OPERATORS  --------------------------------------------                                 

<Op Exp>        ::= <Op Exp> '|' <Or Exp>                                 ! boring encoding of prefix/infix operator precedence  
                    | <Or Exp>

<Or Exp>        ::=  <Or Exp> 'or' <And Exp>       
                    | <And Exp> 

<And Exp>       ::=  <And Exp> 'and' <Not Exp>                                          
                    | <Not Exp>                                          

<Not Exp>       ::= 'not' <Comp Exp>                                          
                    | <Comp Exp>  

<Comp Exp>      ::= <Sum Exp> '=' <Sum Exp>
                    | <Sum Exp> '<>' <Sum Exp>
                    | <Sum Exp> '<=' <Sum Exp>
                    | <Sum Exp> '>=' <Sum Exp>
                    | <Sum Exp> '<' <Sum Exp>
                    | <Sum Exp> '>' <Sum Exp>
                    | <Sum Exp>

<Sum Exp>       ::= <Sum Exp> '+' <Mult Exp>
                    | <Sum Exp> '-' <Mult Exp>                                          
                    | <Mult Exp> 

<Mult Exp>      ::= <Mult Exp> '*' <Neg Exp> 
                    | <Mult Exp> '/' <Neg Exp>                                           
                    | <Neg Exp> 

<Neg Exp>       ::= '-' <Conc Exp> 
                    | '∂' <Conc Exp>
                    | '<-' <Conc Exp>
                    | <Conc Exp>
                    
<Conc Exp>      ::= <Conc Exp> '++' <Powr Exp>
                    | <Powr Exp>
                    
<Powr Exp>      ::= <Powr Exp> '^' <Base Exp>                               ! -2^2 = -4;  -2^-2 is error, use -2^(-2)
                    | <Base Exp>

! UNITS  --------------------------------------------                                 

<Volume>        ::= Id     ! 'L' | 'mL' | 'uL' | 'μL' | 'nL'  | 'pL' | 'ml' | 'ul' | 'μl' | 'nl' | 'pl'
<Temperature>   ::= Id     ! 'K' | 'Kelvin' | 'C' | 'Celsius'
<Quantity>      ::= Id     ! 'kg' | 'g' | 'mg' | 'ug' | 'μg' | 'ng' | 'pg' | 'kM' | 'M' | 'mM' | 'uM' | 'μM' | 'nM' | 'pM' | 'kmol' | 'mol' | 'mmol' | 'umol' | 'μmol' | 'nmol' | 'pmol'



========================================
Grammar Properties
========================================

Name                Kaemika grammar
Author              Luca Cardelli
Version             1
About               A Language for Modularizing Chemistry
Case Sensitive      True
Start Symbol        Top
Auto Whitespace     True
Character Mapping   Windows-1252
Character Set       Unicode
Generated By        GOLD Parser Builder 5.2.0.
Generated Date      2020-01-26 11:31


========================================
Defined Sets
========================================

{StringChar}     &20, &21, &23 .. &5B, &5D .. &80, &82 .. &8C, &8E, &91 .. &9C, &9E .. &200A, &2010 .. &2027, &202F .. &205F, &2065 .. &2069, &2070 .. &D7FF, &E000 .. &FEFE, &FF00 .. &FFEF


========================================
Lexical Groups
========================================

0    Comment Line
1    Comment Block




========================================
Terminals
========================================

 0      (EOF)
 1      (Error)
 2      Comment
 3      NewLine
 4      Whitespace
 5      '*/'
 6      '/*'
 7      '//'
 8      '-'
 9      '#'
 10     '('
 11     ')'
 12     '*'
 13     ','
 14     '/'
 15     ';'
 16     '@'
 17     '['
 18     ']'
 19     '^'
 20     '{'
 21     '|'
 22     '}'
 23     '+'
 24     '++'
 25     '<'
 26     '<-'
 27     '<='
 28     '<>'
 29     '<->'
 30     '='
 31     '>'
 32     '->'
 33     '>='
 34     '>>'
 35     '∂'
 36     amount
 37     and
 38     as
 39     bool
 40     by
 41     concentrate
 42     constant
 43     define
 44     dispose
 45     Double
 46     draw
 47     else
 48     elseif
 49     end
 50     equilibrate
 51     false
 52     Float
 53     flow
 54     for
 55     from
 56     fun
 57     function
 58     Id
 59     if
 60     in
 61     Integer
 62     list
 63     mix
 64     net
 65     network
 66     not
 67     number
 68     Ø
 69     omega
 70     or
 71     parameter
 72     QuotedString
 73     rand
 74     random
 75     regulate
 76     report
 77     sample
 78     species
 79     split
 80     string
 81     then
 82     to
 83     true
 84     yield


========================================
Nonterminals
========================================

85      <Allocation>
86      <And Exp>
87      <Base Exp>
88      <Comp Exp>
89      <Complex>
90      <Conc Exp>
91      <Draw>
92      <Else>
93      <Else Exp>
94      <EmptySample>
95      <EndCondition>
96      <Expression>
97      <Expressions>
98      <ExpressionSeq>
99      <Fun>
100     <Fun Instance>
101     <Function>
102     <Header>
103     <Headers>
104     <Ids>
105     <IdSeq>
106     <Mult Exp>
107     <Neg Exp>
108     <Net>
109     <Net Instance>
110     <Network>
111     <Not Exp>
112     <Op Exp>
113     <Or Exp>
114     <Param>
115     <Params>
116     <ParamSeq>
117     <Pattern>
118     <Powr Exp>
119     <Quantity>
120     <Rand>
121     <Random>
122     <Rate>
123     <Reaction>
124     <Report>
125     <Reports>
126     <Sample>
127     <Simplex>
128     <Species>
129     <Statement>
130     <Statements>
131     <Substance>
132     <Substances>
133     <Sum Exp>
134     <Temperature>
135     <Top>
136     <Transition>
137     <Volume>


========================================
Rules
========================================

0       <Top> ::= <Statements>
1       <Function> ::= Id '=' <Expression>
2       <Function> ::= Id <Fun>
3       <Fun> ::= <Headers> '{' <Expression> '}'
4       <Network> ::= Id '=' <Expression>
5       <Network> ::= Id <Net>
6       <Net> ::= <Header> '{' <Statements> '}'
7       <Random> ::= Id '=' <Expression>
8       <Random> ::= Id <Rand>
9       <Rand> ::= '(' omega Id ')' '{' <Expression> '}'
10      <EmptySample> ::= Id '{' <Expression> <Volume> ',' <Expression> <Temperature> '}'
11      <Sample> ::= Id '=' <Expression>
12      <Sample> ::= <EmptySample>
13      <Sample> ::= Id
14      <Species> ::= Id '=' <Expression>
15      <Species> ::= '{' <Substances> '}'
16      <Species> ::= <Substances> '@' <Expression> <Quantity> <Allocation>
17      <Headers> ::= <Headers> <Header>
18      <Headers> ::= <Header>
19      <Header> ::= '(' <Params> ')'
20      <Params> ::= <ParamSeq>
21      <Params> ::= 
22      <ParamSeq> ::= <ParamSeq> ',' <Param>
23      <ParamSeq> ::= <Param>
24      <Param> ::= bool <Ids>
25      <Param> ::= number <Ids>
26      <Param> ::= string <Ids>
27      <Param> ::= list <Ids>
28      <Param> ::= flow <Ids>
29      <Param> ::= species <Ids>
30      <Param> ::= sample <Ids>
31      <Param> ::= function <Ids>
32      <Param> ::= network <Ids>
33      <Param> ::= random <Ids>
34      <Param> ::= <Pattern>
35      <Pattern> ::= '[' <Params> ']'
36      <Pattern> ::= '[' <Params> ']' '++' list Id
37      <Pattern> ::= list Id '++' '[' <Params> ']'
38      <Ids> ::= <Ids> Id
39      <Ids> ::= Id
40      <IdSeq> ::= <IdSeq> ',' Id
41      <IdSeq> ::= Id
42      <Allocation> ::= in <Expression>
43      <Allocation> ::= 
44      <Substances> ::= <Substances> ',' <Substance>
45      <Substances> ::= <Substance>
46      <Substance> ::= Id '#' <Expression>
47      <Substance> ::= Id
48      <Statements> ::= <Statements> <Statement>
49      <Statements> ::= 
50      <Statement> ::= <Net Instance>
51      <Statement> ::= <Reaction>
52      <Statement> ::= bool Id '=' <Expression>
53      <Statement> ::= number Id '=' <Expression>
54      <Statement> ::= string Id '=' <Expression>
55      <Statement> ::= list Id '=' <Expression>
56      <Statement> ::= flow Id '=' <Expression>
57      <Statement> ::= random <Random>
58      <Statement> ::= constant <IdSeq>
59      <Statement> ::= parameter Id '<-' <Expression>
60      <Statement> ::= species <Species>
61      <Statement> ::= sample <Sample>
62      <Statement> ::= function <Function>
63      <Statement> ::= network <Network>
64      <Statement> ::= <Pattern> '=' <Expression>
65      <Statement> ::= amount <Ids> '@' <Expression> <Quantity> <Allocation>
66      <Statement> ::= report <Reports>
67      <Statement> ::= if <Expression> then <Statements> <Else>
68      <Statement> ::= <Draw>
69      <Statement> ::= ';'
70      <Statement> ::= mix Id '=' <ExpressionSeq>
71      <Statement> ::= split <IdSeq> '=' <Expression> by <ExpressionSeq>
72      <Statement> ::= split <IdSeq> '=' <Expression>
73      <Statement> ::= dispose <ExpressionSeq>
74      <Statement> ::= regulate <IdSeq> '=' <ExpressionSeq> to <Expression> <Temperature>
75      <Statement> ::= regulate <IdSeq> to <Expression> <Temperature>
76      <Statement> ::= concentrate <IdSeq> '=' <ExpressionSeq> to <Expression> <Volume>
77      <Statement> ::= concentrate <IdSeq> to <Expression> <Volume>
78      <Statement> ::= equilibrate <IdSeq> '=' <ExpressionSeq> <EndCondition>
79      <Statement> ::= equilibrate <IdSeq> <EndCondition>
80      <Statement> ::= equilibrate <EndCondition>
81      <Net Instance> ::= Id '(' <Expressions> ')'
82      <Else> ::= elseif <Expression> then <Statements> <Else>
83      <Else> ::= else <Statements> end
84      <Else> ::= end
85      <Draw> ::= draw <Expression> from <Expression>
86      <Reaction> ::= <Transition>
87      <Reaction> ::= <Complex> '>>' <Transition>
88      <Transition> ::= <Complex> '->' <Complex>
89      <Transition> ::= <Complex> '->' '{' <Rate> '}' <Complex>
90      <Transition> ::= <Complex> '->' <Complex> '{' <Rate> '}'
91      <Transition> ::= <Complex> '<->' <Complex>
92      <Transition> ::= <Complex> '{' <Rate> '}' '<->' '{' <Rate> '}' <Complex>
93      <Transition> ::= <Complex> '<->' <Complex> '{' <Rate> '}' '{' <Rate> '}'
94      <Rate> ::= <Expression>
95      <Rate> ::= <Expression> ',' <Expression>
96      <Rate> ::= '{' <Expression> '}'
97      <Complex> ::= <Complex> '+' <Simplex>
98      <Complex> ::= <Simplex>
99      <Simplex> ::= Integer Id
100     <Simplex> ::= Id '*' Id
101     <Simplex> ::= Id
102     <Simplex> ::= '#'
103     <Simplex> ::= Ø
104     <Expression> ::= <Op Exp>
105     <Base Exp> ::= <Fun Instance>
106     <Base Exp> ::= true
107     <Base Exp> ::= false
108     <Base Exp> ::= Integer
109     <Base Exp> ::= Float
110     <Base Exp> ::= Double
111     <Base Exp> ::= QuotedString
112     <Base Exp> ::= if <Expression> then <Expression> <Else Exp>
113     <Base Exp> ::= fun <Fun>
114     <Base Exp> ::= net <Net>
115     <Base Exp> ::= rand <Rand>
116     <Base Exp> ::= '(' <Expression> ')'
117     <Base Exp> ::= '[' <Expressions> ']'
118     <Base Exp> ::= <Draw>
119     <Base Exp> ::= define <Statements> yield <Expression>
120     <Fun Instance> ::= Id
121     <Fun Instance> ::= <Fun Instance> '(' <Expressions> ')'
122     <Else Exp> ::= elseif <Expression> then <Expression> <Else Exp>
123     <Else Exp> ::= else <Expression> end
124     <Expressions> ::= <ExpressionSeq>
125     <Expressions> ::= 
126     <ExpressionSeq> ::= <ExpressionSeq> ',' <Expression>
127     <ExpressionSeq> ::= <Expression>
128     <Reports> ::= <Reports> ',' <Report>
129     <Reports> ::= <Report>
130     <Report> ::= <Expression> as <Expression>
131     <Report> ::= <Expression>
132     <EndCondition> ::= for <Expression>
133     <Op Exp> ::= <Op Exp> '|' <Or Exp>
134     <Op Exp> ::= <Or Exp>
135     <Or Exp> ::= <Or Exp> or <And Exp>
136     <Or Exp> ::= <And Exp>
137     <And Exp> ::= <And Exp> and <Not Exp>
138     <And Exp> ::= <Not Exp>
139     <Not Exp> ::= not <Comp Exp>
140     <Not Exp> ::= <Comp Exp>
141     <Comp Exp> ::= <Sum Exp> '=' <Sum Exp>
142     <Comp Exp> ::= <Sum Exp> '<>' <Sum Exp>
143     <Comp Exp> ::= <Sum Exp> '<=' <Sum Exp>
144     <Comp Exp> ::= <Sum Exp> '>=' <Sum Exp>
145     <Comp Exp> ::= <Sum Exp> '<' <Sum Exp>
146     <Comp Exp> ::= <Sum Exp> '>' <Sum Exp>
147     <Comp Exp> ::= <Sum Exp>
148     <Sum Exp> ::= <Sum Exp> '+' <Mult Exp>
149     <Sum Exp> ::= <Sum Exp> '-' <Mult Exp>
150     <Sum Exp> ::= <Mult Exp>
151     <Mult Exp> ::= <Mult Exp> '*' <Neg Exp>
152     <Mult Exp> ::= <Mult Exp> '/' <Neg Exp>
153     <Mult Exp> ::= <Neg Exp>
154     <Neg Exp> ::= '-' <Conc Exp>
155     <Neg Exp> ::= '∂' <Conc Exp>
156     <Neg Exp> ::= '<-' <Conc Exp>
157     <Neg Exp> ::= <Conc Exp>
158     <Conc Exp> ::= <Conc Exp> '++' <Powr Exp>
159     <Conc Exp> ::= <Powr Exp>
160     <Powr Exp> ::= <Powr Exp> '^' <Base Exp>
161     <Powr Exp> ::= <Base Exp>
162     <Volume> ::= Id
163     <Temperature> ::= Id
164     <Quantity> ::= Id


