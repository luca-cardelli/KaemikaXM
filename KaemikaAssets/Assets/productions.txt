============================================================
GOLD Parser Builder
Version 5.2.0.
============================================================


========================================
Grammar
========================================

"Name"    = Kaemika grammar
"Author"  = Luca Cardelli
"Version" = 1
"About"   = A Language for Modularizing Chemistry
          
"Case Sensitive" = True
"Start Symbol"   = <Top>

Id        = ({Letter}|{Greek and Coptic})({AlphaNumeric}|{Greek and Coptic}|'_'|{Superscripts and Subscripts}|'')*           ! Letter followed by alphanumerics or single-quote, underscore, Unicode sup/sub
Integer   = {Digit}+
Float     = {Digit}+ '.' {Digit}+
Double    = {Digit}+ ('.' {Digit}+)? [Ee] [+-]? {Digit}+
{StringChar} = {All Printable} - ["\]
QuotedString = '"' ({StringChar} | '\'{All Printable})* '"'
          
Comment Line  = '//'
Comment Start = '/*'
Comment End   = '*/'
Comment Block @= { Nesting = All }
                
! PREAMBLE --------------------------------------------

<Top>           ::=  <Statements>
             
! ABSTRACTIONS  --------------------------------------------
                          
<Function>       ::= Id '=' <Expression>                                     ! binding a function value to a function id
                    | Id <Fun>                                               ! function id definition
<Fun>            ::= <Headers> '{' <Expression> '}'                          ! function abstraction

<Network>        ::= Id '=' <Expression>                                     ! binding a network value to a network id
                    | Id <Net>                                               ! network id definition
<Net>            ::= <Header> '{' <Statements> '}'                           ! network abstraction (networks are nothing but functions that do not return values)

<Random>         ::= Id '=' <Expression>                                     ! binding a random variable value to a random variabl id
                    | Id <Rand>                                              ! random variable id definition
<Rand>           ::= '(' 'omega' Id ')' '{' <Expression> '}'                 ! random variable abstraction
                  
<EmptySample>    ::= Id '{' <Expression> <Volume> ',' <Expression> <Temperature> '}'
<Sample>         ::= Id '=' <Expression>                                     ! binding a sample value to a sample id
                    | <EmptySample>                                          ! empty sample definition, parameterized by volume and temperature
                    | Id                                                     ! empty sample definition, default volume (1 mL) and temperature (20 Celsius)

<Species>        ::= Id '=' <Expression>                                     ! binding a species value to a species id
                    | '{' <Substances> '}'                                   ! declaration of multiple species (unallocated)
                    | <Substances> '@' <Expression> <Quantity> <Allocation>  ! allocation of multiple <Ids> species to a sample, 
                                                                             !     short for '{'<Substances>'}' ';' 'amount' <Ids> '@' <Expression> <Quantity> <Allocation>

<Headers>        ::= <Headers> <Header>
                    | <Header>
                                      
<Header>         ::= '(' <Params> ')'

<Params>           ::= <ParamSeq>
                    |                                                  
<ParamSeq>         ::= <ParamSeq> ',' <Param>
                    | <Param>

<Param>          ::= 'bool' <Ids>                  ! booleans      
                    | 'number' <Ids>               ! numbers
                    | 'string' <Ids>               ! strings
                    | 'list' <Ids>                 ! lists
                    | 'flow' <Ids>                 ! flows                   
                    | 'species' <Ids>              ! species are values. n.b. individual reactions are not values, but networks are
                    | 'sample' <Ids>               ! samples are containers that have volume and temperature, populated with species that have concentrations
                    | 'function' <Ids>             ! functions can receive and return values, species, functions, and networks  
                    | 'network' <Ids>              ! networks can receive values, species, functions, and networks, and return nothing    
                    | 'random' <Ids>               ! random variables    
                    | 'value' <Ids>                ! untyped variables    
                    | <Ids>                        ! same as: 'value' <Ids>
                    | <Pattern>                    ! list pattern matching 

<Pattern>       ::= '[' <Params> ']'                  ! a fixed length list pattern
                    | '[' <Params> ']' '++' 'list' Id  ! a variable length list pattern, with tail on the right
                    | 'list' Id '++' '[' <Params> ']'  ! a variable length list pattern, with tail on the left

<Ids>           ::= <Ids> Id
                    | Id
                    
<IdSeq>         ::= <IdSeq> ',' Id
                    | Id
                                                              
<Allocation>     ::= 'in' <Expression>     ! allocation of species or reports to a sample
                    |                      ! short for 'in' 'vessel'
<Substances>     ::= <Substances> ',' <Substance>
                    | <Substance>
<Substance>      ::= Id '#' <Expression>
                    | Id
                  
! STATEMENTS --------------------------------------------

<Statements>    ::= <Statements> <Statement>  
                    |

<Statement>     ::=   <Net Instance>                          ! there are no obligatory delimiter characters between statements. LALR FTW!
                    | <Reaction>                              ! reactions are the only statements not prefixed by a keyword (other than instances)
                    | 'bool' Id '=' <Expression>              ! binding a bool value to a bool id
                    | 'number' Id '=' <Expression>            ! binding a number value to a number id
                    | 'string' Id '=' <Expression>            ! binding a string value to a string id
                    | 'list' Id '=' <Expression>              ! binding a list value to a list id
                    | 'flow' Id '=' <Expression>              ! binding a flow value to a flow id
                    | 'random' <Random>                       ! binding a random variable value to a random variable id
                    | 'constant' <IdSeq>                      ! an undetermined constant (used for exporting ODEs containing symbolic constants)
                    | 'parameter' Id '<-' <Expression>        ! drawing a parameter from a random variable (and displaying it in the GUI)
                    | 'species' <Species>                     ! binding a species to a species id or species def
                    | 'sample' <Sample>                       ! binding a sample to a sample id or sample def
                    | 'function' <Function>                   ! binding a function to a function id or function def
                    | 'network' <Network>                     ! binding a network to a network id or network def
                    | 'value' Id '=' <Expression>             ! binding any value to an id (useful in polymorphic functions)
                    | <Pattern> '=' <Expression>              ! binding list elements to ids; length and types must match                  
                    | 'amount' <Ids> '@' <Expression> <Quantity> <Allocation>  ! set initial quantity of species in a sample
                    | 'report' <Reports> <Allocation>                          ! report species for plotting (can use arithmetic, but restrictions apply)
                    | 'if' <Expression> 'then' <Statements> <Else>             ! conditional
                    | <Draw>                                                   ! draw samples from (lists of) functions or random variables and plot them
                    | ';'                                                      ! rarely used optional syntactic noise for same-line multiple statements
                    
                    | 'mix' Id '=' <ExpressionSeq>                                ! mix samples and name the new sample
                    | 'split' <IdSeq> '=' <Expression> 'by' <ExpressionSeq>       ! split a sample by propotions and name them
                    | 'split' <IdSeq> '=' <Expression>                            ! split in equal parts
                    | 'dispose' <ExpressionSeq>                                   ! dispose samples (those samples cannot be reused)
                    | 'regulate' <IdSeq> '=' <ExpressionSeq> 'to' <Expression> <Temperature>  ! change samples temperature to value (heat or cool)
                    | 'regulate' <IdSeq> 'to' <Expression> <Temperature>                      ! short for 'regulate' Ids '=' Ids 'to' ...
                    | 'concentrate' <IdSeq> '=' <ExpressionSeq> 'to' <Expression> <Volume>    ! change samples volume to value (evaporate or dilute)
                    | 'concentrate' <IdSeq> 'to' <Expression> <Volume>                        ! short for 'concentrate' Ids '=' Ids 'to' ...
                    | 'equilibrate' <IdSeq> '=' <ExpressionSeq> <EndCondition>    ! integrate samples for a time, and name the new samples
                    | 'equilibrate' <IdSeq> <EndCondition>                        ! short for 'equilibrate' Ids '=' Ids <EndCondition> (reusing the sample Ids)
                    | 'equilibrate' <EndCondition>                                ! short for 'equilibrate' 'vessel' '=' 'vessel' <EndCondition> (default sample)
                
<Net Instance>   ::= Id '(' <Expressions> ')'

<Else>           ::=  'elseif' <Expression> 'then' <Statements> <Else>  ! cascading if statements: else is optional
                    | 'else' <Statements> 'end'
                    | 'end'

<Draw>          ::= 'draw' <Expression> 'from' <Expression>
                                   
! REACTIONS --------------------------------------------

<Reaction>      ::= <Transition> 
                    | '∂' Id '=' <Expression>                     ! ODE; short for the reaction Ø -> Id {{<Expression>}}
                    | <Complex> '>>' <Transition>                 ! optional catalysis notation, A >> B -> C == A + B -> A + C, etc.
               
<Transition>    ::= <Complex> '->' <Complex>                                              ! default rate (collision frequncy = 1.0, activation energy = 0.0)
                    | <Complex> '->' '{' <Rate> '}' <Complex>                             ! rate in the middle of reaction
                    | <Complex> '->' <Complex> '{' <Rate> '}'                             ! or rate after reaction
                    | <Complex> '<->' <Complex>                                           ! reversible, default rate (= 1.0, 0.0)
                    | <Complex> '{' <Rate> '}' '<->' '{' <Rate> '}' <Complex>             ! rate in the middle of reaction
                    | <Complex> '<->' <Complex> '{' <Rate> '}' '{' <Rate> '}'             ! or rate after reaction, {reverse} then {direct}

<Rate>          ::= <Expression>                                                          ! collision frequency (with activation energy = 0.0)
                    | <Expression> ',' <Expression>                                       ! collision frequency, activation energy (joules per mole)
                    | '{' <Expression> '}'                                                ! arbitrary kinetic law: any function from a sample to a non-negative number

<Complex>       ::= <Complex> '+' <Simplex>
                    | <Simplex>
                
<Simplex>       ::= Integer <Compound>                                  ! stoichiometry: '2a' is the same as 'a + a'
                    | Id '*' <Compound> | Id '·' <Compound>             ! stoichiometry: 'n * a' is the same as 'a + ... + a' n times for integer n>=0
                    | <Compound>                                        ! a species
                    | '#' | 'Ø'                                         ! zero species: for creation and degradation
                    
<Compound>      ::= Id                                                  ! a mass action substance 'a' has rate contribution 'a'
                    | Id 'act' <Hill>                                   ! a Hill activator: 'a act(k,n)' has rate contribution 'a^n/(a^n+k^n)' and is catalytic
                    | Id 'inh' <Hill>                                   ! a Hill inhibitor: 'a act(k,n)' has rate contribution '1/(a^n+k^n)' and is catalytic
                    | Id 'deg' 'act' <Hill>                             ! a Hill degrading activator: 'a deg act' has rate contribution 'a^n/(a^n+k^n)' and is non catalytic
                    | Id 'deg' 'inh' <Hill>                             ! a Hill degrading inhibitor: 'a deg inh' has rate contribution '1/(a^n+k^n)' and is non catalytic
                    
<Hill>          ::= '(' <Expression> ')'                               ! Hill microscopic dissociation constant k (actually k can be any expression), and Hill default coefficient n = 1
                    | '(' <Expression> ',' <Expression> ')'             ! Hill microscopic dissociation constant k, and Hill coefficient n
                    |                                                   ! Hill default microscopic dissociation constant k = 1, and Hill default coefficient n = 1

! EXPRESSIONS --------------------------------------------
          
<Expression>    ::=  <Op Exp>                                               ! see below
                 
<Base Exp>      ::= <Fun Instance> 
                    | 'true' | 'false'                                      ! bool literal
                    | Integer | Float | Double                              ! double floating point literal. use int(n) to round to integers
                    | QuotedString                                          ! double-quoted string literal. use \" and \\ to represent " and \
                    | 'if' <Expression> 'then' <Expression> <Else Exp>      ! no statements allowed inside if-expressions: uses if-statements for that
                    | 'fun' <Fun> | 'λ' <Fun>                               ! function abstraction
                    | 'net' <Net> | 'η' <Net>                               ! network abstraction
                    | 'rand' <Rand>                                         ! random variable abstraction
                    | '(' <Expression> ')'                                  ! parenthesized expression
                    | '[' <Expressions> ']'                                 ! list
                    | <Draw>                                                ! draw a list from (lists of) functions or random variables
                    | 'define' <Statements> 'yield' <Expression>            ! ambigous syntax because of no 'end' bracket. 
                                                                            ! E.g. (define number n = 3 yield n) + 3   vs. define number n = 3 return (n + 3)
                                                                            ! is resolved as the latter
                  
<Fun Instance>      ::= Id                                                  ! built-in math library operators, and pi and e, follow this syntax too
                    | <Fun Instance> '(' <Expressions> ')'                  ! function invocations can use currying             
                     
<Else Exp>       ::=  'elseif' <Expression> 'then' <Expression> <Else Exp>  ! cascading if expressions: else is compulsory
                    | 'else' <Expression> 'end'
                           
<Expressions>    ::= <ExpressionSeq>
                    |
<ExpressionSeq>  ::= <ExpressionSeq> ',' <Expression>
                    | <Expression>
                                        
<Reports>        ::= <Reports> ',' <Report>
                    | <Report>
                    
<Report>         ::=  Id '=' <Expression> 'as' <Expression>                  ! use the string after 'as' in legends as the name of this report
                    | Id '=' <Expression>                                    ! bind a flow-valued timecourse from this report to Id
                    | <Expression> 'as' <Expression>                         ! use the string after 'as' in legends as the name of this report
                    | <Expression>                                           ! a flow to plot

<EndCondition>   ::= 'for' <Expression>
                  
! OPERATORS  --------------------------------------------                                 

<Op Exp>        ::= <Op Exp> '|' <Or Exp>                                 ! boring encoding of prefix/infix operator precedence  
                    | <Or Exp>

<Or Exp>        ::=  <Or Exp> 'or' <And Exp>       
                    | <And Exp> 

<And Exp>       ::=  <And Exp> 'and' <Not Exp>                                          
                    | <Not Exp>                                          

<Not Exp>       ::= 'not' <Comp Exp>                                          
                    | <Comp Exp>  

<Comp Exp>      ::= <Sum Exp> '=' <Sum Exp>
                    | <Sum Exp> '<>' <Sum Exp>
                    | <Sum Exp> '<=' <Sum Exp>
                    | <Sum Exp> '>=' <Sum Exp>
                    | <Sum Exp> '<' <Sum Exp>
                    | <Sum Exp> '>' <Sum Exp>
                    | <Sum Exp>

<Sum Exp>       ::= <Sum Exp> '+' <Mult Exp>
                    | <Sum Exp> '-' <Mult Exp>                                          
                    | <Mult Exp> 

<Mult Exp>      ::= <Mult Exp> '*' <Neg Exp> 
                    | <Mult Exp> '·' <Neg Exp>                 ! alternative to '*'                          
                    | <Mult Exp> '/' <Neg Exp>                                           
                    | <Neg Exp> 

<Neg Exp>       ::= '-' <Conc Exp> 
                    | '∂' <Conc Exp>
                    | '<-' <Conc Exp>
                    | <Conc Exp>
                    
<Conc Exp>      ::= <Conc Exp> '++' <Powr Exp>
                    | <Powr Exp>
                    
<Powr Exp>      ::= <Powr Exp> '^' <Base Exp>                               ! -2^2 = -4;  -2^-2 is error, use -2^(-2)
                    | <Base Exp>

! UNITS  --------------------------------------------                                 

<Volume>        ::= Id     ! 'L' | 'mL' | 'uL' | 'μL' | 'nL'  | 'pL' | 'ml' | 'ul' | 'μl' | 'nl' | 'pl'
<Temperature>   ::= Id     ! 'K' | 'Kelvin' | 'C' | 'Celsius'
<Quantity>      ::= Id     ! 'kg' | 'g' | 'mg' | 'ug' | 'μg' | 'ng' | 'pg' | 'kM' | 'M' | 'mM' | 'uM' | 'μM' | 'nM' | 'pM' | 'kmol' | 'mol' | 'mmol' | 'umol' | 'μmol' | 'nmol' | 'pmol'



========================================
Grammar Properties
========================================

Name                Kaemika grammar
Author              Luca Cardelli
Version             1
About               A Language for Modularizing Chemistry
Case Sensitive      True
Start Symbol        Top
Auto Whitespace     True
Character Mapping   Windows-1252
Character Set       Unicode
Generated By        GOLD Parser Builder 5.2.0.
Generated Date      2020-04-22 13:35


========================================
Defined Sets
========================================

{StringChar}     &20, &21, &23 .. &5B, &5D .. &80, &82 .. &8C, &8E, &91 .. &9C, &9E .. &200A, &2010 .. &2027, &202F .. &205F, &2065 .. &2069, &2070 .. &D7FF, &E000 .. &FEFE, &FF00 .. &FFEF


========================================
Lexical Groups
========================================

0    Comment Line
1    Comment Block




========================================
Terminals
========================================

 0      (EOF)
 1      (Error)
 2      Comment
 3      NewLine
 4      Whitespace
 5      '*/'
 6      '/*'
 7      '//'
 8      '-'
 9      '#'
 10     '('
 11     ')'
 12     '*'
 13     ','
 14     '/'
 15     ';'
 16     '@'
 17     '['
 18     ']'
 19     '^'
 20     '{'
 21     '|'
 22     '}'
 23     '+'
 24     '++'
 25     '<'
 26     '<-'
 27     '<='
 28     '<>'
 29     '<->'
 30     '='
 31     '>'
 32     '->'
 33     '>='
 34     '>>'
 35     '∂'
 36     '·'
 37     act
 38     amount
 39     and
 40     as
 41     bool
 42     by
 43     concentrate
 44     constant
 45     define
 46     deg
 47     dispose
 48     Double
 49     draw
 50     else
 51     elseif
 52     end
 53     equilibrate
 54     false
 55     Float
 56     flow
 57     for
 58     from
 59     fun
 60     function
 61     Id
 62     if
 63     in
 64     inh
 65     Integer
 66     list
 67     mix
 68     net
 69     network
 70     not
 71     number
 72     Ø
 73     omega
 74     or
 75     parameter
 76     QuotedString
 77     rand
 78     random
 79     regulate
 80     report
 81     sample
 82     species
 83     split
 84     string
 85     then
 86     to
 87     true
 88     value
 89     yield
 90     η
 91     λ


========================================
Nonterminals
========================================

92      <Allocation>
93      <And Exp>
94      <Base Exp>
95      <Comp Exp>
96      <Complex>
97      <Compound>
98      <Conc Exp>
99      <Draw>
100     <Else>
101     <Else Exp>
102     <EmptySample>
103     <EndCondition>
104     <Expression>
105     <Expressions>
106     <ExpressionSeq>
107     <Fun>
108     <Fun Instance>
109     <Function>
110     <Header>
111     <Headers>
112     <Hill>
113     <Ids>
114     <IdSeq>
115     <Mult Exp>
116     <Neg Exp>
117     <Net>
118     <Net Instance>
119     <Network>
120     <Not Exp>
121     <Op Exp>
122     <Or Exp>
123     <Param>
124     <Params>
125     <ParamSeq>
126     <Pattern>
127     <Powr Exp>
128     <Quantity>
129     <Rand>
130     <Random>
131     <Rate>
132     <Reaction>
133     <Report>
134     <Reports>
135     <Sample>
136     <Simplex>
137     <Species>
138     <Statement>
139     <Statements>
140     <Substance>
141     <Substances>
142     <Sum Exp>
143     <Temperature>
144     <Top>
145     <Transition>
146     <Volume>


========================================
Rules
========================================

0       <Top> ::= <Statements>
1       <Function> ::= Id '=' <Expression>
2       <Function> ::= Id <Fun>
3       <Fun> ::= <Headers> '{' <Expression> '}'
4       <Network> ::= Id '=' <Expression>
5       <Network> ::= Id <Net>
6       <Net> ::= <Header> '{' <Statements> '}'
7       <Random> ::= Id '=' <Expression>
8       <Random> ::= Id <Rand>
9       <Rand> ::= '(' omega Id ')' '{' <Expression> '}'
10      <EmptySample> ::= Id '{' <Expression> <Volume> ',' <Expression> <Temperature> '}'
11      <Sample> ::= Id '=' <Expression>
12      <Sample> ::= <EmptySample>
13      <Sample> ::= Id
14      <Species> ::= Id '=' <Expression>
15      <Species> ::= '{' <Substances> '}'
16      <Species> ::= <Substances> '@' <Expression> <Quantity> <Allocation>
17      <Headers> ::= <Headers> <Header>
18      <Headers> ::= <Header>
19      <Header> ::= '(' <Params> ')'
20      <Params> ::= <ParamSeq>
21      <Params> ::= 
22      <ParamSeq> ::= <ParamSeq> ',' <Param>
23      <ParamSeq> ::= <Param>
24      <Param> ::= bool <Ids>
25      <Param> ::= number <Ids>
26      <Param> ::= string <Ids>
27      <Param> ::= list <Ids>
28      <Param> ::= flow <Ids>
29      <Param> ::= species <Ids>
30      <Param> ::= sample <Ids>
31      <Param> ::= function <Ids>
32      <Param> ::= network <Ids>
33      <Param> ::= random <Ids>
34      <Param> ::= value <Ids>
35      <Param> ::= <Ids>
36      <Param> ::= <Pattern>
37      <Pattern> ::= '[' <Params> ']'
38      <Pattern> ::= '[' <Params> ']' '++' list Id
39      <Pattern> ::= list Id '++' '[' <Params> ']'
40      <Ids> ::= <Ids> Id
41      <Ids> ::= Id
42      <IdSeq> ::= <IdSeq> ',' Id
43      <IdSeq> ::= Id
44      <Allocation> ::= in <Expression>
45      <Allocation> ::= 
46      <Substances> ::= <Substances> ',' <Substance>
47      <Substances> ::= <Substance>
48      <Substance> ::= Id '#' <Expression>
49      <Substance> ::= Id
50      <Statements> ::= <Statements> <Statement>
51      <Statements> ::= 
52      <Statement> ::= <Net Instance>
53      <Statement> ::= <Reaction>
54      <Statement> ::= bool Id '=' <Expression>
55      <Statement> ::= number Id '=' <Expression>
56      <Statement> ::= string Id '=' <Expression>
57      <Statement> ::= list Id '=' <Expression>
58      <Statement> ::= flow Id '=' <Expression>
59      <Statement> ::= random <Random>
60      <Statement> ::= constant <IdSeq>
61      <Statement> ::= parameter Id '<-' <Expression>
62      <Statement> ::= species <Species>
63      <Statement> ::= sample <Sample>
64      <Statement> ::= function <Function>
65      <Statement> ::= network <Network>
66      <Statement> ::= value Id '=' <Expression>
67      <Statement> ::= <Pattern> '=' <Expression>
68      <Statement> ::= amount <Ids> '@' <Expression> <Quantity> <Allocation>
69      <Statement> ::= report <Reports> <Allocation>
70      <Statement> ::= if <Expression> then <Statements> <Else>
71      <Statement> ::= <Draw>
72      <Statement> ::= ';'
73      <Statement> ::= mix Id '=' <ExpressionSeq>
74      <Statement> ::= split <IdSeq> '=' <Expression> by <ExpressionSeq>
75      <Statement> ::= split <IdSeq> '=' <Expression>
76      <Statement> ::= dispose <ExpressionSeq>
77      <Statement> ::= regulate <IdSeq> '=' <ExpressionSeq> to <Expression> <Temperature>
78      <Statement> ::= regulate <IdSeq> to <Expression> <Temperature>
79      <Statement> ::= concentrate <IdSeq> '=' <ExpressionSeq> to <Expression> <Volume>
80      <Statement> ::= concentrate <IdSeq> to <Expression> <Volume>
81      <Statement> ::= equilibrate <IdSeq> '=' <ExpressionSeq> <EndCondition>
82      <Statement> ::= equilibrate <IdSeq> <EndCondition>
83      <Statement> ::= equilibrate <EndCondition>
84      <Net Instance> ::= Id '(' <Expressions> ')'
85      <Else> ::= elseif <Expression> then <Statements> <Else>
86      <Else> ::= else <Statements> end
87      <Else> ::= end
88      <Draw> ::= draw <Expression> from <Expression>
89      <Reaction> ::= <Transition>
90      <Reaction> ::= '∂' Id '=' <Expression>
91      <Reaction> ::= <Complex> '>>' <Transition>
92      <Transition> ::= <Complex> '->' <Complex>
93      <Transition> ::= <Complex> '->' '{' <Rate> '}' <Complex>
94      <Transition> ::= <Complex> '->' <Complex> '{' <Rate> '}'
95      <Transition> ::= <Complex> '<->' <Complex>
96      <Transition> ::= <Complex> '{' <Rate> '}' '<->' '{' <Rate> '}' <Complex>
97      <Transition> ::= <Complex> '<->' <Complex> '{' <Rate> '}' '{' <Rate> '}'
98      <Rate> ::= <Expression>
99      <Rate> ::= <Expression> ',' <Expression>
100     <Rate> ::= '{' <Expression> '}'
101     <Complex> ::= <Complex> '+' <Simplex>
102     <Complex> ::= <Simplex>
103     <Simplex> ::= Integer <Compound>
104     <Simplex> ::= Id '*' <Compound>
105     <Simplex> ::= Id '·' <Compound>
106     <Simplex> ::= <Compound>
107     <Simplex> ::= '#'
108     <Simplex> ::= Ø
109     <Compound> ::= Id
110     <Compound> ::= Id act <Hill>
111     <Compound> ::= Id inh <Hill>
112     <Compound> ::= Id deg act <Hill>
113     <Compound> ::= Id deg inh <Hill>
114     <Hill> ::= '(' <Expression> ')'
115     <Hill> ::= '(' <Expression> ',' <Expression> ')'
116     <Hill> ::= 
117     <Expression> ::= <Op Exp>
118     <Base Exp> ::= <Fun Instance>
119     <Base Exp> ::= true
120     <Base Exp> ::= false
121     <Base Exp> ::= Integer
122     <Base Exp> ::= Float
123     <Base Exp> ::= Double
124     <Base Exp> ::= QuotedString
125     <Base Exp> ::= if <Expression> then <Expression> <Else Exp>
126     <Base Exp> ::= fun <Fun>
127     <Base Exp> ::= λ <Fun>
128     <Base Exp> ::= net <Net>
129     <Base Exp> ::= η <Net>
130     <Base Exp> ::= rand <Rand>
131     <Base Exp> ::= '(' <Expression> ')'
132     <Base Exp> ::= '[' <Expressions> ']'
133     <Base Exp> ::= <Draw>
134     <Base Exp> ::= define <Statements> yield <Expression>
135     <Fun Instance> ::= Id
136     <Fun Instance> ::= <Fun Instance> '(' <Expressions> ')'
137     <Else Exp> ::= elseif <Expression> then <Expression> <Else Exp>
138     <Else Exp> ::= else <Expression> end
139     <Expressions> ::= <ExpressionSeq>
140     <Expressions> ::= 
141     <ExpressionSeq> ::= <ExpressionSeq> ',' <Expression>
142     <ExpressionSeq> ::= <Expression>
143     <Reports> ::= <Reports> ',' <Report>
144     <Reports> ::= <Report>
145     <Report> ::= Id '=' <Expression> as <Expression>
146     <Report> ::= Id '=' <Expression>
147     <Report> ::= <Expression> as <Expression>
148     <Report> ::= <Expression>
149     <EndCondition> ::= for <Expression>
150     <Op Exp> ::= <Op Exp> '|' <Or Exp>
151     <Op Exp> ::= <Or Exp>
152     <Or Exp> ::= <Or Exp> or <And Exp>
153     <Or Exp> ::= <And Exp>
154     <And Exp> ::= <And Exp> and <Not Exp>
155     <And Exp> ::= <Not Exp>
156     <Not Exp> ::= not <Comp Exp>
157     <Not Exp> ::= <Comp Exp>
158     <Comp Exp> ::= <Sum Exp> '=' <Sum Exp>
159     <Comp Exp> ::= <Sum Exp> '<>' <Sum Exp>
160     <Comp Exp> ::= <Sum Exp> '<=' <Sum Exp>
161     <Comp Exp> ::= <Sum Exp> '>=' <Sum Exp>
162     <Comp Exp> ::= <Sum Exp> '<' <Sum Exp>
163     <Comp Exp> ::= <Sum Exp> '>' <Sum Exp>
164     <Comp Exp> ::= <Sum Exp>
165     <Sum Exp> ::= <Sum Exp> '+' <Mult Exp>
166     <Sum Exp> ::= <Sum Exp> '-' <Mult Exp>
167     <Sum Exp> ::= <Mult Exp>
168     <Mult Exp> ::= <Mult Exp> '*' <Neg Exp>
169     <Mult Exp> ::= <Mult Exp> '·' <Neg Exp>
170     <Mult Exp> ::= <Mult Exp> '/' <Neg Exp>
171     <Mult Exp> ::= <Neg Exp>
172     <Neg Exp> ::= '-' <Conc Exp>
173     <Neg Exp> ::= '∂' <Conc Exp>
174     <Neg Exp> ::= '<-' <Conc Exp>
175     <Neg Exp> ::= <Conc Exp>
176     <Conc Exp> ::= <Conc Exp> '++' <Powr Exp>
177     <Conc Exp> ::= <Powr Exp>
178     <Powr Exp> ::= <Powr Exp> '^' <Base Exp>
179     <Powr Exp> ::= <Base Exp>
180     <Volume> ::= Id
181     <Temperature> ::= Id
182     <Quantity> ::= Id


